//====- ConvOptimize.cpp --------------------------------------------------===//
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//===----------------------------------------------------------------------===//
//
// This file implements the Conv2DNhwcFhwcOp optimize.
//
//===----------------------------------------------------------------------===//

#include <mlir/Dialect/Affine/IR/AffineOps.h>
#include <mlir/Dialect/Func/IR/FuncOps.h>
#include <mlir/Dialect/Linalg/Transforms/Transforms.h>
#include <mlir/IR/IntegerSet.h>
#include <mlir/Pass/Pass.h>

using namespace mlir;
using namespace vector;

//===----------------------------------------------------------------------===//
// Rewrite Pattern
//===----------------------------------------------------------------------===//

namespace {

class ConvNhwcFhwcOptimizePattern : public ConversionPattern {
public:
  explicit ConvNhwcFhwcOptimizePattern(MLIRContext *context,
                                       int64_t vecSizeParam,
                                       int64_t kernelMParam,
                                       int64_t kernelNParam)
      : ConversionPattern(linalg::Conv2DNhwcFhwcOp::getOperationName(), 1,
                          context) {
    vecSize = vecSizeParam;
    kernelM = kernelMParam;
    kernelN = kernelNParam;
  }

  LogicalResult
  matchAndRewrite(Operation *op, ArrayRef<Value> /*operands*/,
                  ConversionPatternRewriter &rewriter) const override {
    auto loc = op->getLoc();

    // Some constant we need.
    const Value c0 =
        rewriter.create<arith::ConstantOp>(loc, rewriter.getIndexAttr(0));
    const Value cf0 =
        rewriter.create<arith::ConstantOp>(loc, rewriter.getF32FloatAttr(0.));

    const AffineExpr d0 = rewriter.getAffineDimExpr(0);
    const AffineExpr d1 = rewriter.getAffineDimExpr(1);
    const AffineExpr s0 = rewriter.getAffineSymbolExpr(0);

    Value input = op->getOperand(0);
    Value filter = op->getOperand(1);
    Value output = op->getOperand(2);

    ShapedType inputTy = input.getType().cast<ShapedType>();

    Type elemTy = inputTy.getElementType();
    VectorType vecTy = VectorType::get(vecSize, elemTy);

    // Dims
    Value N = rewriter.create<memref::DimOp>(loc, output, 0);  // N
    Value OH = rewriter.create<memref::DimOp>(loc, output, 1); // OH
    Value OW = rewriter.create<memref::DimOp>(loc, output, 2); // OW
    Value OC = rewriter.create<memref::DimOp>(loc, output, 3); // OC
    Value IC = rewriter.create<memref::DimOp>(loc, input, 3);  // IC
    Value FH = rewriter.create<memref::DimOp>(loc, filter, 1); // FH
    Value FW = rewriter.create<memref::DimOp>(loc, filter, 2); // FW

    // memref<1xvector<vecsize x elemTy>>
    MemRefType bufferTy = MemRefType::get(1, vecTy);
    Value buffer = rewriter.create<memref::AllocOp>(loc, bufferTy);

    // clang format off
    //  Step 1: Create outer most loops.
    //  N
    affine::buildAffineLoopNest(
        rewriter, loc, c0, N, 1,
        [&](OpBuilder &, Location loc, ValueRange ivRange) {
          Value ivN = ivRange.front();
          // OH

          affine::buildAffineLoopNest(
              rewriter, loc, c0, OH, 1,
              [&](OpBuilder &builder, Location loc, ValueRange ivRange) {
                Value ivOH = ivRange.front();
                // OW
                affine::buildAffineLoopNest(
                    rewriter, loc, c0, OW, 1,
                    [&](OpBuilder &, Location loc, ValueRange ivRange) {
                      Value ivOW = ivRange.front();
                      // OC
                      affine::buildAffineLoopNest(
                          rewriter, loc, c0, OC, 1,
                          [&](OpBuilder &, Location loc, ValueRange ivRange) {
                            Value ivOC = ivRange.front();
                            Value t = builder.create<SplatOp>(loc, vecTy, cf0);
                            builder.create<memref::StoreOp>(loc, t, buffer, c0);

                            // FH
                            Value fixedFH =
                                builder.create<affine::AffineApplyOp>(
                                    loc,
                                    AffineMap::get(
                                        1, 0, d0.ceilDiv(kernelM) * kernelM),
                                    ValueRange{FH});
                            affine::buildAffineLoopNest(
                                rewriter, loc, c0, fixedFH, kernelM,
                                [&]([[maybe_unused]] OpBuilder &builder,
                                    Location loc, ValueRange ivRange) {
                                  Value ivFH = ivRange.front();

                                  // FW
                                  Value fixedFW =
                                      builder.create<affine::AffineApplyOp>(
                                          loc,
                                          AffineMap::get(1, 0,
                                                         d0.ceilDiv(kernelN) *
                                                             kernelN),
                                          ValueRange{FW});
                                  affine::buildAffineLoopNest(
                                      rewriter, loc, c0, fixedFW, kernelN,
                                      [&]([[maybe_unused]] OpBuilder &builder,
                                          Location loc, ValueRange ivRange) {
                                        Value ivFW = ivRange.front();
                                        Value fixedIC =
                                            builder
                                                .create<affine::AffineApplyOp>(
                                                    loc,
                                                    AffineMap::get(
                                                        1, 0,
                                                        d0.ceilDiv(versize) *
                                                            vecsize),
                                                    ValueRange{IC});
                                        affine::buildAffineLoopNest(
                                            rewriter, loc, c0, fixedIC, vecSize,
                                            [&](OpBuilder &builder,
                                                Location loc,
                                                ValueRange ivRange) {
                                              Value ivIC = ivRange.front();

                                              SmallVector<Value> iList;
                                              SmallVector<Value> fList;
                                              for (int i = 0; i < kernelM;
                                                   ++i) {
                                                Value rowInput = builder.create<
                                                    affine::AffineApplyOp>(
                                                    loc,
                                                    AffineMap::get(2, 0,
                                                                   d0 + i + d1),
                                                    ValueRange{ivOH, ivFH});
                                                Value rowFilter =
                                                    builder.create<
                                                        affine::AffineApplyOp>(
                                                        loc,
                                                        AffineMap::get(1, 0,
                                                                       d0 + i),
                                                        ivFH);
                                                for (int j = 0; j < kernelN;
                                                     ++j) {
                                                  Value columnInput =
                                                      builder.create<
                                                          affine::
                                                              AffineApplyOp>(
                                                          loc,
                                                          AffineMap::get(
                                                              2, 0,
                                                              d0 + d1 + j),
                                                          ValueRange{ivOW,
                                                                     ivFW});
                                                  Value columnFilter =
                                                      builder.create<
                                                          affine::
                                                              AffineApplyOp>(
                                                          loc,
                                                          AffineMap::get(
                                                              1, 0, d0 + j),
                                                          ivFW);

                                                  Value i = builder.create<
                                                      TransferReadOp>(
                                                      loc, vecTy, input,
                                                      ValueRange{ivN, ivIC,
                                                                 rowInput,
                                                                 columnInput});

                                                  auto protectedF =
                                                      builder.create<
                                                          affine::AffineIfOp>(
                                                          loc, vecTy,
                                                          IntegerSet::get(
                                                              1, 1,
                                                              {s0 - 1 - d0},
                                                              {false}),
                                                          ValueRange{rowFilter,
                                                                     FH},
                                                          true);

                                                  // if row in range, read
                                                  // normally.
                                                  auto thenBuilder =
                                                      protectedF
                                                          .getThenBodyBuilder();
                                                  Value normalReadVec =
                                                      thenBuilder.create<
                                                          TransferReadOp>(
                                                          loc, vecTy, filter,
                                                          ValueRange{
                                                              ivOC, ivIC,
                                                              rowFilter,
                                                              columnFilter});
                                                  thenBuilder.create<
                                                      affine::AffineYieldOp>(
                                                      loc, normalReadVec);

                                                  // if row out of range, give
                                                  // back N empty vector.
                                                  auto elseBuilder =
                                                      protectedF
                                                          .getElseBodyBuilder();
                                                  Value emptyVec =
                                                      elseBuilder
                                                          .create<SplatOp>(
                                                              loc, vecTy, cf0);
                                                  elseBuilder.create<
                                                      affine::AffineYieldOp>(
                                                      loc, emptyVec);

                                                  iList.push_back(i);
                                                  fList.push_back(
                                                      protectedF->getOpResult(
                                                          0));
                                                }
                                              }
                                              Value lastResult =
                                                  builder
                                                      .create<memref::LoadOp>(
                                                          loc, buffer, c0);
                                              for (int i = 0; i < kernelM;
                                                   ++i) {
                                                for (int j = 0; j < kernelN;
                                                     ++j) {
                                                  lastResult = builder.create<
                                                      vector::FMAOp>(
                                                      loc, vecTy,
                                                      iList[i * kernelN + j],
                                                      fList[i * kernelN + j],
                                                      lastResult);
                                                }
                                              }

                                              builder.create<memref::StoreOp>(
                                                  loc, lastResult, buffer, c0);
                                            });
                                      });
                                });

                            Value reduceVec =
                                builder.create<memref::LoadOp>(loc, buffer, c0);
                            Value reducedRes =
                                builder.create<vector::ReductionOp>(
                                    loc, vector::CombiningKind::ADD, reduceVec);
                            Value bias = builder.create<memref::LoadOp>(
                                loc, output, ValueRange{ivN, ivOC, ivOH, ivOW});
                            Value addRes = builder.create<arith::AddFOp>(
                                loc, bias, reducedRes);
                            builder.create<memref::StoreOp>(
                                loc, addRes, output,
                                ValueRange{ivN, ivOC, ivOH, ivOW});
                          });
                    });
              });
        });
    // clang format on

    rewriter.create<memref::DeallocOp>(loc, buffer);

    rewriter.eraseOp(op);
    return success();
  }

private:
  int64_t vecSize;
  int64_t kernelM;
  int64_t kernelN;
};
} // end anonymous namespace

//===----------------------------------------------------------------------===//
// ConvNhwcFhwcOptimizePass
//===----------------------------------------------------------------------===//

namespace {
class ConvNhwcFhwcOptimizePass
    : public PassWrapper<ConvNhwcFhwcOptimizePass, OperationPass<ModuleOp>> {
public:
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvNhwcFhwcOptimizePass)
  StringRef getArgument() const final { return "conv-nhwc-fhwc-optimize"; }
  StringRef getDescription() const final {
    return "Conv2d NHWC FHWC optimize.";
  }
  ConvNhwcFhwcOptimizePass() = default;
  ConvNhwcFhwcOptimizePass(const ConvNhwcFhwcOptimizePass &) {}
  explicit ConvNhwcFhwcOptimizePass(int64_t vecSizeParam, int64_t kernelMParam,
                                    int64_t kernelNParam) {
    vecSize = vecSizeParam;
    kernelM = kernelMParam;
    kernelN = kernelNParam;
  }

  void runOnOperation() override;

  void getDependentDialects(DialectRegistry &registry) const override {
    registry.insert<linalg::LinalgDialect, scf::SCFDialect,
                    affine::AffineDialect, VectorDialect>();
  }

  Option<int64_t> vecSize{*this, "vec-size",
                          llvm::cl::desc("Vector size using in kernel."),
                          llvm::cl::init(16)};

  Option<int64_t> kernelM{
      *this, "kernel-m",
      llvm::cl::desc("Specify how many rows kernel will contain."),
      llvm::cl::init(4)};

  Option<int64_t> kernelN{
      *this, "kernel-n",
      llvm::cl::desc("Specify how many columns kernel will cantain."),
      llvm::cl::init(2)};
};
} // end anonymous namespace.

void ConvNhwcFhwcOptimizePass::runOnOperation() {
  MLIRContext *context = &getContext();
  ModuleOp module = getOperation();

  ConversionTarget target(*context);
  target
      .addLegalDialect<arith::ArithDialect, affine::AffineDialect,
                       scf::SCFDialect, memref::MemRefDialect, VectorDialect>();
  target.addLegalOp<ModuleOp, func::FuncOp, func::ReturnOp>();
  target.addLegalOp<linalg::FillOp>();

  RewritePatternSet patterns(context);
  patterns.add<ConvNhwcFhwcOptimizePattern>(context, vecSize, kernelM, kernelN);

  if (failed(applyPartialConversion(module, target, std::move(patterns))))
    signalPassFailure();
}

namespace mlir {
namespace buddy {
void registerConvNhwcFhwcOptimizePass() {
  PassRegistration<ConvNhwcFhwcOptimizePass>();
}
} // namespace buddy
} // namespace mlir
